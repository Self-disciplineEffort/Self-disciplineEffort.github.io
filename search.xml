<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python笔记(三)</title>
    <url>/2020/04/12/Python%E7%AC%94%E8%AE%B0-%E4%B8%89/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Python笔记(一)</title>
    <url>/2020/04/05/Python%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>##第一章<br>1-1 Python开发环境<br>    小要求：最好能够熟悉Linux基本操作，Linux是程序员的必备开发使用系统。</p>
<pre><code>基于windows操作系统，安装开发环境。（不会的话可以上B站搜索相应的安装视频）
    Python官方网址（www.python.org）
    接着寻找相应的操作系统的Python版本。
    在选择的时候尽量把两个条件都选择上，减少你后期配置Path的环境变量的时间

    如果你想要集成开发环境，可以下载一个Pycharm
    官网下载地址：https://www.jetbrains.com/pycharm/download/
    安装地址：
    http://www.runoob.com/w3cnote/pycharm-windows-install.html
    具体的配置可以去B站搜搜看，这里我提供一个地址（也许会失效）：
    https://www.bilibili.com/video/BV17b411e7M9?from=search&amp;seid=4945926071261645762

    Eclips也可以配置Python环境，然后创建文件就可以了。奇猫的第一个视频会有详细步骤，如果遇到乱码，
    那么就是编码集出了问题。你需要调整一下你的编码集</code></pre><p>1-2 变量与解释器内存管理</p>
<pre><code>变量：
例如：a = 1   地址:0x1122  b = 2 地址：0x3344
     改 a 的值 a = 2 地址 0x3344  
     此时 a 和 b 的地址都是一样的，都是0x3344

解释器内存管理机制:

 先取一定数量的大小为256Kb的arenas空间，然后以链表的形式记录里面用过的空间。
 每一个arenas也是以链表的方式进行连接，每一个arenas中用过的数据都是以链表的方式连接，没用过的内容也是以链表方式连接。
 当你调用值时，那么先从已经记录过的地址去寻找，如果没有就新开辟一个地址。python解释器的垃圾回收机制是不会把你这个内存释放的，
 使用申请到一定量就不能申请了，只能从空闲的地址或arenas里面调用了。</code></pre><p> 1-3 python的基本语法<br>     连接符”反斜杠”：<br>         连接多个物理行，例如：<br>         display = “ This is test func反斜杠<br>                     This is test func反斜杠<br>                     This is test func”</p>
<pre><code> 引号：
     单引号、双引号、三引号标识字符：
     str = &apos;HelloWord&apos;
     str = &quot;HelloWord&quot;
     str = &quot;&quot;&quot;HelloWord&quot;&quot;&quot;
     str = &apos;&apos;&apos;HelloWord&apos;&apos;&apos;

注意事项：
    在输出字符串常量直接引用单引号(&apos;)和双引号(&quot;)的时候
        使用&quot;的时候。字符串定义不难以&quot;开始和结束
        使用&apos;也是同样的道理</code></pre><p>##第二章 Python的数据结构<br>2-1 数据结构——数字<br>    数字的类型： int —&gt; 整型 24字节<br>                long —&gt; 长整型(也许已经和int合并在一起了) 28字节<br>                longa = 10L<br>                float —&gt; 浮点数 24字节<br>                complex —&gt; 复数  32字节<br>                complexa = 4 + 1j<br>                boolean —&gt; 布尔值 24字节</p>
<pre><code>        Python解释器对int、float、有最大限制，
        在赋值的时候python会识别值的类型

默认的数字转换优先级：
    complex &gt; float &gt; long &gt;int

    优先级大转小的时候，会自动转化成大类型然后再进行运算。
    强制转换的时候需要加（）
    特别说明complex：
    complex（x）  把x转换为实部x和虚部为零的复数
    complex（x,y） 把x和y转换为实数部分x和虚部y的复数

我们现实的数字和计算机的数字区别：
    计算机里面的数字都是以二进制补码的方式存在的。
        当数字为正数时：原码 = 反码 = 补码
        当数字为负数时：反码 = 原码符号位不变其他取反  补码 = 反码 + 1

        计算机内部的数字运算都是以补码的方式进行运算的。

    位运算：
        &amp;（与） |（或） &gt;&gt;（右移） &lt;&lt;（左移） ~（取反） ^(异或)

    数字的标准函数：
        位运算的优先级 ~ &gt; (&lt;&lt;) &gt; (&gt;&gt;) &gt; &amp; &gt; ^ &gt; |

        标准函数：
            abs 绝对值 
            cmp（x,y） x &gt; y:return 1| x = y:return 0 | x &lt; y:return -1
            max(x,y,z....) 返回最大值
            min(x,y,z....) 返回最小值

    随机数:
        随机数使用时 导入包 import random

        1. random.random() 用于生成一个0 &lt;= n &lt; 1.0 的随机浮点数
        2.random.uniform(a,b) 用于生成一个指定指定范围的随机浮点数
        3.random.randint(a,b)用于生成一个指定指定范围的随机整数（a,b分别是上线）
        4.random.randrange([start],[top],[step]),从指定范围内，按照step递增的集合获取数。
        5.random.choice(sequence) 从序列中获取一个随机元素.
        6.random.shuffle(x[,random]) 用于将一个列表中的元素打乱
        例如：items = [1,2,3,4,5,6] random.shuffle(items)
        7.random.sample(sqeuence,k)从指定序列中随机获取一个指定长度的片断。</code></pre><p>2-2数据结构——序列<br>    序列包含了字符串（string）、列表（list）、元组类型（tuple）<br>        三种类型<br>            字符串和元组是固定长度，不能修改。列表可以插入、删除、替换。</p>
<pre><code>    三者的索引值：
        正索引：0 ~ len - 1 和java、C语言一样
        负索引（python独有）：-len ~ -1   -1代表最后一位。

基本操作和切片操作
    基本操作
        obj in seq ：obj是否再seq中
        obj not in seq ：obj是否不在seq中
        seq + seq1 ： 连接序列seq和seq1，两者的序列要一致
        seq * N ：序列重复相加N次
    切片操作
        [index] :取索引index出的元素
        [start:stop] :取所以start到stop的所有元素
        [start:stop:step：在索引start到stop之间，每隔step个取一个元素
序列的内建函数
    len ：返回列表长度
    max/min(seq) :返回列表最大值/最小值
    sum（seq） ： 返回seq的整形的总和
    reversed(seq) :以一个序列作为参数，返回一个逆序访问的迭代器 
    例如：a = reversed([1,2,3])
    zip(seq1,seq2...) :受任意多个（包括0个和1 个）序列作为参数，返回 一个tuple（元组）列表
    例如：zip(&quot;123&quot;,&quot;456&quot;)= [(1,4),(2,5),(3,6)]</code></pre><p>2-3 字符串<br>    字符串：单引号(‘)、双引号(“”)或者三引号(‘’’/“””)定义字符串，字符串的内容是不可变的。<br>        创建和赋值操作：<br>            str1 = “helloWorld”<br>            str1 = str(10)<br>            str1 = str([1,2,3,4,5])<br>            str1 = str((1,2,3,4,5))<br>        访问：<br>            str1= “helloWorld”<br>            print str1[1] = “e”<br>            print str1[1:3] = “el”<br>            print str1[1:9:3] = “eor”</p>
<pre><code>    字符串的内容不可被修改
    例如 ：str1[1] = &apos;a&apos; 是错误的

格式化输出
    %c  把数值转化为字符  print(&quot;%c&quot; % 65) ==》 A
    %d     把数字转为10进制数 print(&quot;%d&quot; % 65)
    %s  把str()把参数转化为字符串 print(&quot;%s&quot; % [1,2,3])
    %o %O 将数字转为8进制数 print(&quot;%o&quot; % 65)
    %x %X 将数字转为16进制数 print(&quot;%x&quot; % 65) 
    %f %F 将数字转为浮点 print(&quot;%f&quot; % 65.1) 
    %% 输出% print(&quot;%%&quot;)
原始字符穿操作符(r/R)
    1.所有的字符串都是直接按照字面意思来使用，没有转义特殊或不能打印的字符
    2.print(&quot;\n&quot;)和print(r&quot;\n&quot;)的不同
        &quot;\n&quot;是一个换行符
        r&quot;\n&quot;是字符\+n，实际值是转义字符\+n组成：&quot;\\n&quot;

    字符串如果想要修改或者截取，那就必须要新建一个字符串

    python字符串结尾不需要&apos;\0&apos;结尾i，只是你包含所定义的字符串的值
    python解释器来管理字符串的内存。

字符串的基本操作
     1.+   
     2.*   
     4.[::]  切片操作 
     5.cmp() 比较两个字符串大小  
     6.len()  字符串长度 
     7.max/min() 字符串中最大/最小元素
     8.str() 接收一个任意对象，生成一个str类型的对象
     9.unicode() 接收一个任意对象,生成一个unicode类型对象
     10.chr() 接受参数在0~255之间整数返回对应的字符
     11.unichar() 12.接受参数在0~0xffff之间整数返回相对应的unicode字符
     13.ord() 根据字符返回对应的ASCII

字符串的函数操作
    1.capitalize 字符串第一个字母大写
    2.count(str,x,y) 统计str在字符串索引x~y之间出现次数
    3.endswith(str,x,y) 判断字符串索引x~y之间是否以str结尾，是返回true，否返回false
    4.find(str,x,y) 查找字符串索引x~y之间是否存在str,是返回true，否返回false
    5.index(str,x,y) 同find,如果没找到str，报异常
    6.join(str1) 字符串本身和str1字符串合并
    7.replace(old,new,max) 把字符串中前max次出现的old替换为new,默认值为全部替换。
    8.upper() 返回小写转化为大写副本
    9.lower() 返回大写转化为小写副本

unicode字符串
    键盘输入值然后unicode会找到对应的字模，经过处理会把字模传给显卡，显卡输出到显示器

    unicode:是为了解决传统的字符编码方案的局限而产生的，它为每种 语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换。每个unicode字符占2个字节 

    unicode显示中国两个字的过程:
    先进行encoder（utf-8）编码成 xx\xx\xx\xx 找到对应的字模，然后和字符集GB2312、utf-8、GBK进行匹配，
    最后传入终端设置编码的格式。

unicode编码格式
    ASCII，ISO-8859-1， UTF-8, UTF-16
    UTF-8使用1~4个字节来表示其他语言的字符
    UTF-16使用2个字节来表示其他语言的字符

    和其他字符的转换：
    • str1 = u&quot;一&apos;  u&apos;\u4e00&apos; 
    • utf8= s.encode(&quot;utf8&quot;)  &apos;\xe4\xb8\x80&apos; 
    • utf8.decoder(&quot;utf8&quot;)  u&apos;\u4e00&apos; 
    • gbk=s.encode(&quot;gbk&quot;)   &apos;\xd2\xbb&apos; 
    • gbk.decoder(&quot;gbk&quot;)  u&apos;\u4e00&apos;</code></pre><p>2-4 数据结构——列表<br>    列表是序列式的数据类型，他可以通过索引或者切片操作来访问一个 或者多个连续的元素；列表元素可以改变</p>
<pre><code>    定义初始化：
        mylist = [1,2,3,4,5]
        mylist = list(&quot;123456&quot;)
        mylist = list((&apos;1&apos;,&apos;2&apos;,&apos;3&apos;))
        mylist = range(10) 返回的值是0123456789以列表存在

    列表更新/修改：mylist[1] = 20

基本操作：
    1. []/[:]/[::] 切片操作 
    2. in/not in 成员关系 
    3. +  连接符 
    4. *  重复操作符 
    5. cmp() 比较两个列表 
    6. len()  返回列表元素个数 
    7. sorted() 列表正序
    8. reversed() 列表反序
    9. sum() 统计列表整数的和
    10. zip(seq1..) 根据seq1和其他列表参数生成一个元组列表(以最短的参数为个数)
    11. range([start,] stop[,step]) 根据start和stop指定范围以及step设置步长，生成一个序列

经常使用的函数：
    1. len(mylist) 列表长度
    2. mylist.append(x) 在列表最后添加元素
    3. mylist.insert(i,x) 在列表位置i处插入元素
    4. mylist.remove(x) 删除值为x元素并且长度-1
    5. mylist.reverse() 列表反序
    6. mylist.pop(i) 弹出并删除位置为i的元素
    7. mylist.sort() 对列表进行一个排序</code></pre><p>2-5 数据结构——元组<br>    定义：元组是python不可变的对象，如果你要更动这个元组，那么就需要新建一个元组，把数据存入其中</p>
<pre><code>创建：
    tuple1 = (&quot;what&quot;,&quot;is&quot;,&quot;python&quot;)
    tuple1 = tuple(&quot;abcd&quot;)
    tuple1 = () 空值
    tuple1 = (&quot;abc&quot;,)

访问：
    tuple1 = (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;)
    print tuple1[10]
    print tuple1[0:3]
    print tuple[0:3:2]

更新、删除：
    tp1 = (&apos;a&apos;,&apos;b&apos;)
    tp2 = (&apos;c&apos;,&apos;d&apos;)
    tp3 = tp1 + tp2
    del tp1

函数：
    cmp(tp1,tp1) 比较元组
    len(tp1) 元组长度
    max/min(tp1) 从元组中返回最大值/最小值的项

不可变性：一旦定义就不能改变，除非你新建一个元组
可变：元组和列表的结合，元组不可变，但是元组里面的可变元素还是可以变的。
元组不可变的应用场景：如果我们把数据传给一个不了解的API接口，同时希望数据不能被改变，此时就可以使用元组

深拷贝和浅拷贝：等我了解清楚再来。</code></pre><p>2-6 数据结构-字典<br>    定义：字典是Python中的唯一的映射类型。映射类型对象里的哈希值（key）和指向的对象（value）是一对多的关系。<br>    它是一个容器类型，能存储任意个数的Python对象，其中也包括其他容器类型。</p>
<pre><code>直接赋值：
    dict = {}
    dict = {&quot;ip&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:80}

dict方法:传入一个元素是列表的元组作为参数
    dict3 = dict((&quot;ip&quot;,&quot;127.0.0.1&quot;),(&quot;port&quot;,90))
    dict3_1 = dict(x = 1,y = 2)
    dict3_2 = dict(**dict3_1)

哈希表：这个是根据key value而直接进行访问的数据结构
dict1            key            key(哈希值)        value
ip:127.0.0.1    ip       hash     134894231556       127.0.0.1
port:90            port  hash     4145156132846        90

字典的访问：dict1[&quot;port&quot;]把key转化成hash值，接着找到对应的ID，根据ID找到对应的值。

字典的键值(key)：
    不允许一个键值对应多个值，如果初始化或者更新过程中出现多个键 值，会存储最后一个对应值，其他的会被自动删除。 
    例如：dict1 = {&quot;prot&quot;:80,&quot;port&quot;:&quot;8000&quot;}
    dict1[&quot;port&quot;] = 8000
    len(dict1) = 1

键值(key)是必须能转化成hash值的：
    Python解释器调用hash函数，根据字典中的键值来存储数据位置，如果键值改变，哈希函数会映射到不同地址来存储数据, 这样哈希函数就不能准确地存储或者获取相关数据。

    不可变的类型是可以hash # tuple、str、freezeset
    可变的类型是不可以hash # list、set

字典的基本操作：
    dict1 = {&quot;ip&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:80}

        访问：dict[key]
             dict1[&quot;ip&quot;]
             for key in dict1:
                     print(&quot;dict[%s] = %s&quot; % (key,dict1[key]))
        更新： dict1[&quot;port&quot;] = &quot;8000&quot;

        删除：
            del(dict1[&quot;ip&quot;])  删除key为ip的条目
            dict1.clear()    删除dict1中的所有条目
            del(dict1) 删除字典dict1
            dict1.pop(&quot;ip&quot;) 删除并返回键值为ip的条目
            dict1.popitem(&quot;ip&quot;)    删除并以元组形式返回字典第一个条目

字典标准函数：dict1 dict2
    str、list、tuple

    list(dict1) 返回dict1的键值从小到大排序的列表
    tuple(dcit1) 返回dict1的键值按键值从小到大排序的元组

    比较运算符cmp(dict1,dict2)，先比较len，再比较各种的key，最后比较value。大于则返回1，反之返回-1，相等返回0

字典相关操作：
    dict1 = {&apos;addr&apos;:{&apos;ip&apos;:&apos;127.0.0.1&apos;,&apos;port&apos;:80},&apos;msg&apos;:18}    字典可以嵌套，value值可以是其他的
    len(dict1)    返回字典（key-value对）的长度
    &apos;key&apos; in dict1 dict1中是否含有&apos;key&apos;键值
    dict1[&apos;name&apos;][ip]字典嵌套字典的key值索引
    dict1.has_key(&apos;key&apos;) 判断字典是否有key键值
    dict1.get(key,default) 如果dict1中有key，返回对应的值，否则返回默认值
    dict1.update(dict2) 合并dict1和dict2
    dict1.setdefault(key，value) 如果字典不存在key，则key默认值为value
    dict1.items() 返回由键和值组成元组列表
    dict1.keys() 返回key列表
    dict1.values() 返回value列表</code></pre><p>##参考文献<br>奇猫的Python教学视频</p>
<p>作者  Luckyboy</p>
]]></content>
      <tags>
        <tag>Python入门和数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础笔记</title>
    <url>/2020/04/04/Java%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="第一章：JAVA的概述"><a href="#第一章：JAVA的概述" class="headerlink" title="第一章：JAVA的概述"></a>第一章：JAVA的概述</h2><h2 id="第二章：基本的语法"><a href="#第二章：基本的语法" class="headerlink" title="第二章：基本的语法"></a>第二章：基本的语法</h2><h2 id="第三章：数组"><a href="#第三章：数组" class="headerlink" title="第三章：数组"></a>第三章：数组</h2><h2 id="第四章：面向对象"><a href="#第四章：面向对象" class="headerlink" title="第四章：面向对象"></a>第四章：面向对象</h2><p>（上）</p>
<p>（中）</p>
<p>（下）</p>
<h2 id="第五章：异常处理"><a href="#第五章：异常处理" class="headerlink" title="第五章：异常处理"></a>第五章：异常处理</h2><p>##参考文献</p>
<p>《JAVA编程思想》、尚硅谷教学视频（宋红康讲授）</p>
<p>作者：Luckyboy</p>
]]></content>
  </entry>
  <entry>
    <title>Python笔记（二）</title>
    <url>/2020/04/11/Python%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>##第三章<br>3-1逻辑结构与控制 if/else/elif<br>    if控制语句：<br>        组成：关键字if、逻辑表达式、逻辑代码<br>        逻辑表达式的结果为：True/False<br>        True：不为空或者0的变量（数组、序列、字典）<br>        False：0、False、None、空的变量(序列、字典)</p>
<pre><code>if(逻辑表达式)：
    代码

特殊的： 表达式                          if语句
         函数    def test():            if(bool((test()-1)):
                     return False        print(&quot;Test return Flase&quot;)
else语句：
    和if语句搭配使用，if和else是一对一的关系。当if（Flase）的时候执行else。
if(else):
    do_yes
else:
    do_no


elif语句：
    检查多个表达式是否为真，并且有对应的代码。
    if(表达式1):
        true1_语句
    elif(表达式2):
        true2_语句
    elif(表达式3):
        true3_语句
    else:
        Flase1_语句

elif和if的嵌套：
    if嵌套是指if中含有if

        if(表达式1):
            if(表达式2):
                true_2语句
        else:
            expr1_false_suite</code></pre><p>3-2逻辑控制—While语句<br>    while循环语句：<br>        代码块中会一直执行，知道条件不满足了，结束语句。<br>        while循环语句分为:有限循环和无限循环<br>    while循环语句语法:<br>        while expression:<br>            do_same_task</p>
<pre><code>while和else语句:
    只有当while循环正常执行完时才会执行else语句
        while和else的配合使用
        i = 0
        while(i &lt; 10):
            print(i)
            i += 1
        else:
            print(&quot;when i = %d,over&quot; % i)

break语句:
    结束当前的循环，跳到下一个语句
    i = 0                        输出结果
    when(i &lt; 10):                    0
        print(i)                    1
        i += 1                        2
        if(i == 5):                    3
            break                     4
    print(&quot;exec over i = %d&quot; % i)    exec over i = 5

continue和pass:
    continue语句：
        结束当前的循环，忽略后面的语句，跳转到循环开始位置，然后根据表达式结果再决定是否循环

    i = 0                         输出结果
    while(i &lt; 10):                    2
        i += 2                        4
        if(i % 2 != 0):                6
            continue                   8
        print(i)

    pass语句：
        空语句，不做任何操作
        作用：保持代码完整性，站位符或者创建站位程序
              一些异常处理，不采取任何措施。</code></pre><p>3-3逻辑控制—for语句<br>    for语句：<br>        用来访问一个可迭代对象中的所有元素。并再遍历所有条目以后结束循环。<br>    for语句语法：<br>        for iter_val in iterable:<br>            iter_val_del<br>        循环索引依次从iterable取值，每循环一次就执行一次iter_val_del</p>
<pre><code>序列：colors = [&quot;green&quot;,&quot;red&quot;,&quot;yellow&quot;,&quot;blue&quot;,&quot;black&quot;]
    使用序列项迭代：
        for color in colors:
            print(color)
    使用索引进行迭代：
        for index in range(len(colors)):
            print(colors[index])
    使用序列和索引进行迭代：
        for index, color in enumerate(colors):
            print(index,color)

遍历字典： dict1 = dict.fromkeys((1,2,3,4,5))
    for key in dict1:
        print(key,dict1[key])

访问迭代器：
    for循环访问迭代器的时候，调用next()方法得到一个条目，然后赋值给目标变量，当访问完后，会产生一个异常。
    for语句在内部会截取这个异常。
        for item in dict1.iteritems():
            print item
range方法：生成一个整数的list
    range(start = 0,stop,step = 1)其中step必须大于0

else语句也是当for语句正常执行完以后，才会触发else语句的内容。
for和else：
    for i in range(10):
        print(i)
    else:
        print(&quot;over i = %d&quot; % i)

迭代器：
    迭代器是一个访问集合内元素的一种方式。迭代器对象从集合的第一个元素开始访问，
    知道所有的元素都被访问一遍以后结束。

    迭代器不能回退，只能往前进行迭代。

    优点：不要求你事先准备好整个迭代过程中所有的元素。
          提供统一访问集合的接口。
          迭代非序列集合(文件)
    迭代器迭代实质：
        迭代器有一个next()方法的对象，当循环访问迭代器的每个元素时，
        调用的是迭代器next()方法，当全部元素取出后，会引发一个StopIteration异常，告诉调用者，迭代完成。

    迭代器使用：
        myiter = iter(&quot;HellWord&quot;)
        while(True):
            print(myiter.next())
    判断对象是否可迭代：
        from collections import Iterable
        isinstance(obj,Iterable)
    单迭代对象：
        只要对象定的话，无论你是否再调用iter()对象，甚至是把这个对象赋值给其他变量名，
        你会发现这些变量指的是同一个地方
        map是单迭代对象
        m1 = range(10);m2 = map(abs,m1);m3 = iter(m2)
        next(m2)出不来，不知道是不是map的原因 map(函数,一个或多个序列)
        next(m3)

    for循环语句的实质:
        for in range(10):
            print(i)
        for循环语句会自动调用工厂函数iter()获得迭代器，然后调用next()方法，并且处理异常。</code></pre><p>3-4逻辑控制—列表解析和生成器<br>    列表解析：动态创建列表，在一个序列的值上应用一个任意表达式，把结果收集到一个新的列表中并返回。</p>
<pre><code>基本语法：[expr for iter_var in iterable]
    mylist = [x+1 for in range(10)]
    [1,2,3,4,5,6,7,8,9,10]

扩展与法：[exper for iter_var in iterable if cond_expr]
mylist = [x+1 for x in range(10) if(x &gt; 5)]
[7,8,9,10]

生成一个矩阵：
    myrange = [(x, y, z) for x in range(3) for y in range(3) for z in range(3) ] 

使用列表解析器统计枫树小于60的个数：
    [x for x in list1 if x &lt; 60]
    把x满足条件的组成一个新的列表然后返回

将列表中小于60的分数替换为False
    [x &gt;= 60 and x for x in list1]
    当x &gt;= 60成立的时候返回X的值，作为列表成员
    当x &gt;= 60不成立的时候返回Flase，作为列表的成员
给定一个字符串，得到每个字符串中单词及其对应的长度
    str = &quot;welcome to python world&quot;
    stuff = [[world,len(world)] ofr world in str1.split()]

生成器：
    表达式：它是列表解析器的一个阔转，分会一个生成器，生成器每次计算出一个条目，把这个条目产生出来。生成器使用延迟算法，他在内存上更为有效。

语法：
    (expr for iter in iterable if cond_expr)

创建:
    L1 = (val for val in range(10))

访问：L1.next()也可能是next(L1)

列表解析器和生成器表达式区别：
    列表解析器需要把所有条目创建出来。
    生成器表达式不需要把条目创建出来，每次计算的时候会把条目创建出来。

在这里需要提及到排序算法，排序算法这里就不作赘述：
以下为比较累排序：
    交换排序：冒泡排序、快速排序
    插入排序：简单插入排序、希尔排序
    选择排序：简单选择排序、堆排序
    归并排序：二路归并排序、多路归并排序

以下为非比较排序
    计数排序、桶排序、基数排序</code></pre><p>##参考视频<br>奇猫的Python教学视频</p>
<p>作者  Luckyboy</p>
]]></content>
      <tags>
        <tag>Python逻辑控制</tag>
      </tags>
  </entry>
</search>
